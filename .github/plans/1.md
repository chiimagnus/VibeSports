# 加载带跑步动画的 3D 角色模型（单个 Runner.usdz + 多段动画）

## TODO List（按 Step 对齐）

> 说明：这里的 TODO 是“施工清单”。勾选状态反映当前仓库进度；未勾选表示还没开始/未完成。

### Step 1：构建 Runner.usdz（裁剪 slow/fast 的多余 skin）

- [x] 维护构建脚本：`scripts/build_runner_usdz.sh`
- [x] 输出 `Runner.usdz` 到：`VibeSports/Resources/Runner.usdz`
- [x] 确认包内不包含 slow/fast 的 mesh/skin（只打包 `SlowRunAnim.usdc` / `FastRunAnim.usdc`）

### Step 1.1：把 Runner.usdz 加进 Xcode target

- [x] 在 Xcode 勾选 `VibeSports/Resources/Runner.usdz` 的 Target Membership
- [x] 在 `Build Phases -> Copy Bundle Resources` 中确认 `Runner.usdz` 已添加

### Step 2：验证 Runner.usdz 多段动画可用

- [x] 增加 Debug Window：`Debug -> Runner Animations…`（可列出 animation keys / Play / Solo / Blend / Rate）
- [x] 验证 `Skeleton.animationKeys` 至少包含 3 段（Idle/SlowRun/FastRun）
- [x] 增加 Debug Window：`Debug -> Runner Tuning…`（可实时调 runner / camera / blend 参数）

### Step 3：在 RunnerSceneRenderer 加载 Runner 并放入场景

- [x] 在 `VibeSports/Services/Renderer/RunnerSceneRenderer.swift` 的 `RunnerSceneAnimator.install(into:)` 加载 `Runner.usdz`
- [x] 以稳定方式定位：
  - `runnerSkinnedNode`（`skinner != nil`）
  - `runnerSkeletonNode`（name = `Skeleton`，递归查找）
- [x] 加入 runner 的位置/缩放/朝向校准参数（先写死，后续再调）
- [x] `reset()` 里复位 runner 节点与动画状态（避免残留/重复 addChild）

### Step 4：三动画播放 + 速度连续混合

- [x] 提取“混合计算”为纯模型：`VibeSports/Models/Runner/RunnerAnimationBlender.swift`
- [x] 添加单测：`VibeSportsTests/RunnerAnimationBlenderTests.swift`
- [x] 在 `RunnerSceneAnimator.renderer(_:updateAtTime:)` 中：
  - 同时 `play()` 三段动画（loop）
  - 每帧更新 `blendFactor`（Idle/Slow/Fast）
  - 更新 `SlowRun/FastRun` 的 `player.speed`（步频随 speed 变化）
- [x] 如有抖动：对 speed 做轻度滤波（可选；当前实现为简单 low-pass）

### Step 5：第三人称相机

- [x] 相机跟随 runner（后上方）并 lookAt runner（或使用 constraint）
- [x] 跑道 recycle 仍保持可用（长跑不跑到尽头）
- [x] 逐步重构：先在现有 cameraZ 推进基础上叠加 runner+follow，再解耦 travelZ（可选；当前已改为显式 `travelZ`）

### Step 6：移除 RunnerAvatarView（emoji 小人）

- [x] 在 `VibeSports/Views/RunnerGame/RunnerGameView.swift` 移除 `RunnerAvatarView` 的引用
- [x] 删除 `VibeSports/Views/RunnerGame/RunnerAvatarView.swift`

## 目标

把底部的 emoji 小人替换为 SceneKit 中的 3D 跑步角色，动画速度与用户实际运动速度绑定，并把视角从第一人称改为第三人称。

本方案 **不做向后兼容**：直接以 `Runner.usdz` 为唯一角色资源，后续逻辑都以“单资源 + 多动画 clip”的方式组织。

## 现状盘点（读代码后的结论）

### 速度数据从哪来？

- 摄像头姿态检测由 `VibeSports/Services/CameraSession.swift` 驱动，`OutputHandler.processingInterval = 1.0 / 20.0`，也就是 **20Hz** 左右更新一次 pose。
- `VibeSports/ViewModels/RunnerGameViewModel.swift` 在每次 pose 更新时调用：
  - `runningMetrics.ingest(pose:now:)` → 得到 `RunningMetricsSnapshot.speedMetersPerSecond`
  - `sceneRenderer.setSpeedMetersPerSecond(snapshot.speedMetersPerSecond)`
- `speedMetersPerSecond` 的范围由 `VibeSports/Models/Running/RunningSpeedModel.swift` 限制：
  - `maxSpeedMetersPerSecond = 6`（约 21.6 km/h）

### SceneKit 场景现在怎么跑？

- `VibeSports/Services/Renderer/RunnerSceneRenderer.swift`
  - `RunnerSceneRenderer.attach(to:)` 绑定 `SCNView.delegate = RunnerSceneAnimator`
  - `RunnerSceneAnimator.renderer(_:updateAtTime:)` 以渲染帧率（通常 60fps）驱动场景更新
  - 当前逻辑维护一个 `travelZ` 作为“前进进度”，runner 的 Z 与跑道 recycle 都基于 `travelZ`
  - 相机为第三人称跟随：相机在 runner 后上方，并 lookAt runner
  - speed 通过 `OSAllocatedUnfairLock` 从 `setSpeedMetersPerSecond` 传到 `updateAtTime`，线程模型是安全的

### UI 里现在的“小人”在哪？

- emoji `RunnerAvatarView` 已从 `VibeSports/Views/RunnerGame/RunnerGameView.swift` 移除
- runner 只存在于 SceneKit 场景内（`RunnerSceneRenderer`）

## 验收标准（一定要能客观验证）

### 资源与动画

- App bundle 中只有 `VibeSports/Resources/Runner.usdz` 作为最终角色资源
- `Runner.usdz` 能被 `SCNScene(named:)` 或 `SCNScene(url:)` 正常加载
- `Skeleton` 节点上能看到 3 个 `animationKeys`（具体 key 可能带完整 USD 路径）：
  - `…/Idle`
  - `…/SlowRun`
  - `…/FastRun`
- `Runner.usdz` **没有打包 3 份 skin**（Slow/Fast 只保留动画层）：
  - `usdzip -l - VibeSports/Resources/Runner.usdz` 显示包含 `SlowRunAnim.usdc`/`FastRunAnim.usdc` 而不是整模型层
  - 这两个 `*Anim.usdc` 的内容不包含 `def Mesh` / `def Material`（只包含 `SkelAnimation` 相关 prim）

### 场景表现

- 场景中能看到 3D runner，大小与跑道比例合理（大致 1.6–1.9m），脚底在地面附近
- `speedMetersPerSecond` 从 0 → 增加时：
  - idle → slow-run → fast-run **连续混合**（没有突然跳帧/突然切动作）
  - 跑步动画的播放速率随 speed 增加（步频明显变快）
- `speedMetersPerSecond` 回到 0 时：自然回 idle（slow/fast 权重为 0）
- 在 `Debug -> Runner Tuning…` 中调整参数能立即影响画面（不需要重启）：
  - Runner：Scale / Yaw / Ahead Z / Ground Y Adj / X
  - Camera：FOV / Height Y / Back Z / LookAt Y / Base X / Bob / Sway
  - Blend：Idle Threshold / Min/Max Run Speed / Base Speed / Min/Max Rate / Speed Smooth α

### 视角与循环赛道

- 相机为第三人称：在 runner 后上方跟随，并看向 runner
- 跑道 segment recycle 仍然正常：长时间跑动不会“跑到尽头”

## Runner Tuning 参数说明（Debug 面板对照）

> 面板入口：`Debug -> Runner Tuning…`。所有参数仅影响运行时，不做持久化；需要时可考虑后续接入 SwiftData Settings。

### Runner（角色）

| 参数 | 单位 | 作用 |
|---|---:|---|
| `Scale` | 无 | 模型缩放（Mixamo 角色常见在 `0.01` 附近） |
| `Yaw (rad)` | 弧度 | 绕 Y 轴旋转，校准面向跑道方向 |
| `Ahead Z` | 场景单位 | runner 的 Z = `travelZ + AheadZ`，用于让 runner 永远在镜头前方 |
| `Ground Y Adj` | 场景单位 | 脚底贴地的额外 Y 微调（基于 skinned node 的 boundingBox 自动算一次，再叠加本值） |
| `X` | 场景单位 | runner 的水平偏移（左右） |

### Camera（第三人称相机）

| 参数 | 单位 | 作用 |
|---|---:|---|
| `FOV (deg)` | 度 | 视角大小（越大越“广角”） |
| `Height Y` | 场景单位 | 相机高度 |
| `Back Z` | 场景单位 | 相机在 runner 后方的距离 |
| `LookAt Y` | 场景单位 | 相机注视点高度（Z/X 跟随 runner） |
| `Base X` | 场景单位 | 相机水平基准偏移（再叠加 sway） |
| `Bob Max / Bob Gain / Bob Freq` | 场景单位 / (单位/速度) / Hz | 镜头上下起伏：振幅 = `min(BobMax, speed * BobGain)`，频率由 BobFreq 控制 |
| `Sway Max / Sway Gain / Sway Freq` | 场景单位 / (单位/速度) / Hz | 镜头左右摆动：振幅 = `min(SwayMax, speed * SwayGain)`，频率由 SwayFreq 控制 |

### Animation Blend（动作混合）

| 参数 | 单位 | 作用 |
|---|---:|---|
| `Idle Threshold` | m/s | 低于该速度时权重偏向 idle（可避免“原地抖动”） |
| `Min Run Speed` | m/s | 进入 slow-run 的起点速度（idle→slow 的过渡区间起点） |
| `Max Run Speed` | m/s | 进入 fast-run 的终点速度（slow→fast 的过渡区间终点） |
| `Base Speed` | m/s | “动画参考速度”，用于把实际速度映射为 clip 播放速率 |
| `Min Rate / Max Rate` | 倍率 | clip 播放速率夹紧范围（避免过慢/过快导致抖动） |
| `Speed Smooth α` | 0..1 | speed 低通滤波强度（越大越灵敏，越小越平滑） |

### 生命周期

- Start/End 会话后：
  - `sceneRenderer.reset()` 能把相机/runner/动画权重复位到初始状态
  - 不出现持续增长的节点数量（避免重复 addChild）

## 资源产物（重要）

### 源素材（不进 App Bundle）

本地保留 3 个“同一角色、同一骨骼”的 USDZ（each with skin + skeleton + one animation）：

- `Idle.usdz`
- `Slow Run.usdz`
- `Fast Run.usdz`

它们只用于构建产物（`Runner.usdz`），不建议放进 Xcode target 的 Copy Bundle Resources。

### App 内最终使用的资源（进 App Bundle）

只保留 1 个：`VibeSports/Resources/Runner.usdz`

这个 `Runner.usdz` 包含：

- **1 份 mesh + skin + 材质**（来自 `Idle`）
- **3 段可独立取用的骨骼动画 clip**（`Idle / SlowRun / FastRun`）
- Slow/Fast 的 mesh/skin 已在打包阶段裁剪掉（只保留动画层），避免“3 份 skin 数据”的体积浪费

## Step 1：构建 Runner.usdz（裁剪掉 slow/fast 的多余 skin）

用脚本把 3 个源 USDZ 合成并裁剪：

```bash
bash scripts/build_runner_usdz.sh \
  --idle "/path/to/Idle.usdz" \
  --slow "/path/to/Slow Run.usdz" \
  --fast "/path/to/Fast Run.usdz" \
  --out  "VibeSports/Resources/Runner.usdz"
```

可选：`--default idle|slow|fast` 用来控制 Quick Look 默认播放哪条动画（仅用于预览，不影响 SceneKit 按 key 取动画）。

### ✅Step 1.1：把 Runner.usdz 加进 Xcode target（容易漏）

确保 `VibeSports/Resources/Runner.usdz` 在 Xcode 里：

- 勾选当前 App target 的 Target Membership
- `Build Phases -> Copy Bundle Resources` 中能看到 `Runner.usdz`

## ✅Step 2：验证 Runner.usdz 是否真的包含多段动画

### ✅2.1 用 Debug Window 验证（推荐）

在 App 里打开：`Debug -> Runner Animations…`（窗口由 `RunnerAnimationDebugView` 提供）。

预期：能看到 3 个 `animationKeys`，并可 Play/Solo/调 `blendFactor`。

### 2.2 用代码验证（备选）

```swift
let scene = try! SCNScene(url: Bundle.main.url(forResource: "Runner", withExtension: "usdz")!)
let skeleton = scene.rootNode.childNode(withName: "Skeleton", recursively: true)!
print(skeleton.animationKeys)
```

预期 key（名称可能带完整路径）：

- `/Runner/mixamorig_Hips/Skeleton/Idle`
- `/Runner/mixamorig_Hips/Skeleton/SlowRun`
- `/Runner/mixamorig_Hips/Skeleton/FastRun`

## Step 3：把角色加载到 RunnerSceneRenderer 的 SceneKit 场景中

### 文件位置

主要改动在 `VibeSports/Services/Renderer/RunnerSceneRenderer.swift`

### 目标改动清单（建议按这个顺序做）

#### 3.1 加载 Runner.usdz 并把节点加入主场景

在 `RunnerSceneAnimator.install(into:)` 中新增 `installRunner(into:)`：

- 从 bundle 加载 `Runner.usdz`
  - 推荐：`SCNScene(named: "Runner.usdz")`（路径就是 bundle 根）
- 把 runner 的根节点挂到 `scene.rootNode`
- 给 runner container 命名（例如 `"runner"`），便于后续查找与 reset

#### 3.2 稳定地定位两个关键节点（不要猜 first child）

需要两个节点：

- `runnerSkinnedNode`：满足 `node.skinner != nil` 的节点（用于渲染与定位身高）
- `runnerSkeletonNode`：`childNode(withName: "Skeleton", recursively: true)`（用于 `animationPlayer(forKey:)` 与混合）

**验收**：两者都能找到，否则在 debug log 里明确提示缺哪个（不要静默失败）。

#### 3.3 Runner 的坐标系与缩放校准

新增一组可调参数（先写死，后续可抽到 Configuration）：

- `runnerScale`（默认 1.0，先以 debug window 里观感为准）
- `runnerGroundY`（脚底贴地所需的 Y 偏移）
- `runnerYawRadians`（面向跑道方向）

建议先实现一个“可见即成功”的 MVP：

- runner 站在地面中心线附近（`x = 0`）
- Z 初始位置在相机前方（先给一个偏移，保证镜头能看到它）

#### 3.4 Reset 行为

在 `RunnerSceneAnimator.reset()` 中：

- 把 runner 位置复位到初始
- 把三段动画的权重复位为 idle=1, slow=0, fast=0
- 把 travel 变量（如果有）复位

### 关键点（坑位清单）

- **不要用 `rootNode.childNodes.first!` 猜节点**：USDZ 顶层经常有包装节点
- 更稳的办法：
  - 先找带 `skinner != nil` 的节点作为渲染用 `runnerNode`
  - 再找命名为 `Skeleton` 的节点作为动画挂载点（`skeletonNode`）

## Step 4：三动画同时播放 + 速度连续混合

### 动画挂载点

`Runner.usdz` 的动画 key 通常挂在 `Skeleton` 节点上（而不是 mesh 节点）。

### 建议先把“混合计算”抽成纯函数（可单测）

在 `VibeSports/Models/` 下新增一个纯模型（不依赖 SceneKit / SwiftUI / Combine）：

- `VibeSports/Models/Runner/RunnerAnimationBlender.swift`（示例命名）

职责：

- 输入：`speedMetersPerSecond`
- 输出：三段权重 `idle/slow/fast`（和为 1）以及 `playbackRate`

对应测试：

- `VibeSportsTests/RunnerAnimationBlenderTests.swift`
  - 权重和为 1（允许极小误差）
  - `speed = 0` 时 idle=1
  - `speed = minRunSpeed` 附近 slow≈1
  - `speed >= maxRunSpeed` 时 fast≈1

这样做的好处：动画混合逻辑一旦稳定，就不需要靠肉眼调试来保证“不会出现权重异常”。

### 混合策略（连续）

三个动画（idle/slow/fast）同时 `play()`，通过 `SCNAnimationPlayer.blendFactor` 控制权重：

- `speed < idleThreshold`：纯 idle
- `idleThreshold ..< minRunSpeed`：idle -> slow 线性过渡
- `minRunSpeed ..< maxRunSpeed`：slow -> fast 线性过渡

并用 `SCNAnimationPlayer.speed` 让步频随真实速度变化（例如 clamp 到 `0.3...3.0`）。

### 推荐的具体参数（先写死，后续再调）

因为 `RunningSpeedModel.maxSpeedMetersPerSecond = 6`，所以可以先用：

- `idleThreshold = 0.10`
- `minRunSpeed = 1.50`
- `maxRunSpeed = 4.50`
- `baseSpeed = 2.00`（用于把速度映射到 playbackRate）
- `playbackRate = clamp(speed / baseSpeed, 0.3...3.0)`

### 推荐实现位置（避免把逻辑放 ViewModel）

混合计算建议放在 `RunnerSceneAnimator.renderer(_:updateAtTime:)` 内部：

- 好处：与渲染帧率一致（60fps），混合更平滑
- 速度值虽然 20Hz 更新，但可以在 Animator 内对 speed 做轻微低通滤波（可选）

可选优化（抖动明显时再做）：

- `displaySpeed = lerp(displaySpeed, speed, alpha)`，例如 `alpha = 0.2`

### 伪代码（Animator 侧最小可行实现）

```swift
// 1) install: 找到 skeletonNode
let skeletonNode = runnerRoot.childNode(withName: "Skeleton", recursively: true)

// 2) 取 3 个 key（key 可能是完整路径）
let idleKey = skeletonNode.animationKeys.first { $0.localizedCaseInsensitiveContains("Idle") }
let slowKey = skeletonNode.animationKeys.first { $0.localizedCaseInsensitiveContains("SlowRun") }
let fastKey = skeletonNode.animationKeys.first { $0.localizedCaseInsensitiveContains("FastRun") }

// 3) 取 player，并 play（repeat forever）
let idlePlayer = skeletonNode.animationPlayer(forKey: idleKey)
idlePlayer.animation.repeatCount = .greatestFiniteMagnitude
idlePlayer.play()

// slow/fast 同理

// 4) 每帧根据 speed 更新 blendFactor + speed
let blend = blender.blend(for: displaySpeed) // (idle, slow, fast, playbackRate)
idlePlayer.blendFactor = blend.idle
slowPlayer.blendFactor = blend.slow
fastPlayer.blendFactor = blend.fast
slowPlayer.speed = blend.playbackRate
fastPlayer.speed = blend.playbackRate
```

## Step 5：第三人称相机（跟随角色，而不是“相机本体向前飞”）

当前实现是“相机向前推进 + bob/sway”；第三人称推荐改成：

- 用一个 `travelZ` 表示世界推进（只影响跑道循环与角色 Z）
- `runnerNode.position.z = travelZ + runnerAheadOffset`
- `cameraNode.position = runnerNode.position + cameraOffset`
- bob/sway 只加在相机局部 offset 上（别叠进 travelZ）

### 建议的最小改动策略（不先动跑道 recycle）

为了降低风险，推荐直接引入一个显式的 `travelZ`（double）作为“世界前进进度”：

- 每帧：`travelZ += speed * dt`
- runner：`runnerZ = travelZ + runnerAheadOffset`
- 相机：`cameraZ = runnerZ - cameraBackOffset`，并 `look(at: runner)`
- 跑道 recycle：用 `runnerZ`（或 `travelZ`）做判断，而不是相机的实际 Z（相机在 runner 后方）

## Step 6：移除旧的 RunnerAvatarView（emoji 小人）

当 3D 角色在场景里跑起来后：

- 删除 `RunnerGameView` 中对 `RunnerAvatarView` 的引用
- 删除 `VibeSports/Views/RunnerGame/RunnerAvatarView.swift`

## 调试 Tips

- Quick Look 只能播“默认动画”，不能用它判断“是否只有一段动画”
- 以 Debug Window / 代码打印 `Skeleton.animationKeys` 为准
- 模型大小/朝向：优先在 DCC（或导出）阶段统一；运行时只做必要的 scale/rotation

## 常见坑（提前写进计划里，避免改到一半卡住）

- `Skeleton` 节点命名依赖导出结果：如果将来换模型，名字可能不是 `Skeleton`，需要改为“按类型/结构查找”或在构建脚本阶段统一命名。
- `animationKeys` 可能是完整 USD 路径，不要硬编码等号匹配；用 `contains("Idle")` 这类方式更稳。
- `RunnerSceneView.updateNSView` 会重复调用 `renderer.attach(to:)`：不要在 `attach` 里做“重复 install/addChild”，否则会越跑节点越多。
- 如果模型脚底漂浮/穿地：优先用 `runnerSkinnedNode.boundingBox` 做一次性 Y 偏移校准（而不是每帧瞎调）。

## 验证命令（修改代码过程中随时跑）

```bash
# 构建 Runner.usdz（如需重新生成）
bash scripts/build_runner_usdz.sh --help

# 资源检查（是否包含多余 skin）
usdzip -l - VibeSports/Resources/Runner.usdz

# 构建与测试
xcodebuild -project VibeSports.xcodeproj -scheme VibeSports -destination 'platform=macOS' build
xcodebuild -project VibeSports.xcodeproj -scheme VibeSports -destination 'platform=macOS' test
```
