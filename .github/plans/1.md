# 加载带跑步动画的 3D 角色模型（单个 Runner.usdz + 多段动画）

## 目标

把底部的 emoji 小人替换为 SceneKit 中的 3D 跑步角色，动画速度与用户实际运动速度绑定，并把视角从第一人称改为第三人称。

本方案 **不做向后兼容**：直接以 `Runner.usdz` 为唯一角色资源，后续逻辑都以“单资源 + 多动画 clip”的方式组织。

## 现状盘点（读代码后的结论）

### 速度数据从哪来？

- 摄像头姿态检测由 `VibeSports/Services/CameraSession.swift` 驱动，`OutputHandler.processingInterval = 1.0 / 20.0`，也就是 **20Hz** 左右更新一次 pose。
- `VibeSports/ViewModels/RunnerGameViewModel.swift` 在每次 pose 更新时调用：
  - `runningMetrics.ingest(pose:now:)` → 得到 `RunningMetricsSnapshot.speedMetersPerSecond`
  - `sceneRenderer.setSpeedMetersPerSecond(snapshot.speedMetersPerSecond)`
- `speedMetersPerSecond` 的范围由 `VibeSports/Models/Running/RunningSpeedModel.swift` 限制：
  - `maxSpeedMetersPerSecond = 6`（约 21.6 km/h）

### SceneKit 场景现在怎么跑？

- `VibeSports/Services/Renderer/RunnerSceneRenderer.swift`
  - `RunnerSceneRenderer.attach(to:)` 绑定 `SCNView.delegate = RunnerSceneAnimator`
  - `RunnerSceneAnimator.renderer(_:updateAtTime:)` 以渲染帧率（通常 60fps）驱动场景更新
  - 当前逻辑是 **相机节点 cameraNode 向 Z 正方向推进**，并基于 `cameraZ` 做地形 segment recycle
  - speed 通过 `OSAllocatedUnfairLock` 从 `setSpeedMetersPerSecond` 传到 `updateAtTime`，线程模型是安全的

### UI 里现在的“小人”在哪？

- `VibeSports/Views/RunnerGame/RunnerGameView.swift` 里 `footerOverlay` 还在显示 `RunnerAvatarView`（emoji 小人）
- 我们最终需要把它删掉，让“小人”只存在于 SceneKit 场景里

## 验收标准（一定要能客观验证）

### 资源与动画

- App bundle 中只有 `VibeSports/Resources/Runner.usdz` 作为最终角色资源
- `Runner.usdz` 能被 `SCNScene(named:)` 或 `SCNScene(url:)` 正常加载
- `Skeleton` 节点上能看到 3 个 `animationKeys`（具体 key 可能带完整 USD 路径）：
  - `…/Idle`
  - `…/SlowRun`
  - `…/FastRun`
- `Runner.usdz` **没有打包 3 份 skin**（Slow/Fast 只保留动画层）：
  - `usdzip -l - VibeSports/Resources/Runner.usdz` 显示包含 `SlowRunAnim.usdc`/`FastRunAnim.usdc` 而不是整模型层
  - 这两个 `*Anim.usdc` 的内容不包含 `def Mesh` / `def Material`（只包含 `SkelAnimation` 相关 prim）

### 场景表现

- 场景中能看到 3D runner，大小与跑道比例合理（大致 1.6–1.9m），脚底在地面附近
- `speedMetersPerSecond` 从 0 → 增加时：
  - idle → slow-run → fast-run **连续混合**（没有突然跳帧/突然切动作）
  - 跑步动画的播放速率随 speed 增加（步频明显变快）
- `speedMetersPerSecond` 回到 0 时：自然回 idle（slow/fast 权重为 0）

### 视角与循环赛道

- 相机为第三人称：在 runner 后上方跟随，并看向 runner
- 跑道 segment recycle 仍然正常：长时间跑动不会“跑到尽头”

### 生命周期

- Start/End 会话后：
  - `sceneRenderer.reset()` 能把相机/runner/动画权重复位到初始状态
  - 不出现持续增长的节点数量（避免重复 addChild）

## 资源产物（重要）

### 源素材（不进 App Bundle）

本地保留 3 个“同一角色、同一骨骼”的 USDZ（each with skin + skeleton + one animation）：

- `Idle.usdz`
- `Slow Run.usdz`
- `Fast Run.usdz`

它们只用于构建产物（`Runner.usdz`），不建议放进 Xcode target 的 Copy Bundle Resources。

### App 内最终使用的资源（进 App Bundle）

只保留 1 个：`VibeSports/Resources/Runner.usdz`

这个 `Runner.usdz` 包含：

- **1 份 mesh + skin + 材质**（来自 `Idle`）
- **3 段可独立取用的骨骼动画 clip**（`Idle / SlowRun / FastRun`）
- Slow/Fast 的 mesh/skin 已在打包阶段裁剪掉（只保留动画层），避免“3 份 skin 数据”的体积浪费

## Step 1：构建 Runner.usdz（裁剪掉 slow/fast 的多余 skin）

用脚本把 3 个源 USDZ 合成并裁剪：

```bash
bash scripts/build_runner_usdz.sh \
  --idle "/path/to/Idle.usdz" \
  --slow "/path/to/Slow Run.usdz" \
  --fast "/path/to/Fast Run.usdz" \
  --out  "VibeSports/Resources/Runner.usdz"
```

可选：`--default idle|slow|fast` 用来控制 Quick Look 默认播放哪条动画（仅用于预览，不影响 SceneKit 按 key 取动画）。

### ✅Step 1.1：把 Runner.usdz 加进 Xcode target（容易漏）

确保 `VibeSports/Resources/Runner.usdz` 在 Xcode 里：

- 勾选当前 App target 的 Target Membership
- `Build Phases -> Copy Bundle Resources` 中能看到 `Runner.usdz`

## ✅Step 2：验证 Runner.usdz 是否真的包含多段动画

### ✅2.1 用 Debug Window 验证（推荐）

在 App 里打开：`Debug -> Runner Animations…`（窗口由 `RunnerAnimationDebugView` 提供）。

预期：能看到 3 个 `animationKeys`，并可 Play/Solo/调 `blendFactor`。

### 2.2 用代码验证（备选）

```swift
let scene = try! SCNScene(url: Bundle.main.url(forResource: "Runner", withExtension: "usdz")!)
let skeleton = scene.rootNode.childNode(withName: "Skeleton", recursively: true)!
print(skeleton.animationKeys)
```

预期 key（名称可能带完整路径）：

- `/Runner/mixamorig_Hips/Skeleton/Idle`
- `/Runner/mixamorig_Hips/Skeleton/SlowRun`
- `/Runner/mixamorig_Hips/Skeleton/FastRun`

## Step 3：把角色加载到 RunnerSceneRenderer 的 SceneKit 场景中

### 文件位置

主要改动在 `VibeSports/Services/Renderer/RunnerSceneRenderer.swift`

### 目标改动清单（建议按这个顺序做）

#### 3.1 加载 Runner.usdz 并把节点加入主场景

在 `RunnerSceneAnimator.install(into:)` 中新增 `installRunner(into:)`：

- 从 bundle 加载 `Runner.usdz`
  - 推荐：`SCNScene(named: "Runner.usdz")`（路径就是 bundle 根）
- 把 runner 的根节点挂到 `scene.rootNode`
- 给 runner container 命名（例如 `"runner"`），便于后续查找与 reset

#### 3.2 稳定地定位两个关键节点（不要猜 first child）

需要两个节点：

- `runnerSkinnedNode`：满足 `node.skinner != nil` 的节点（用于渲染与定位身高）
- `runnerSkeletonNode`：`childNode(withName: "Skeleton", recursively: true)`（用于 `animationPlayer(forKey:)` 与混合）

**验收**：两者都能找到，否则在 debug log 里明确提示缺哪个（不要静默失败）。

#### 3.3 Runner 的坐标系与缩放校准

新增一组可调参数（先写死，后续可抽到 Configuration）：

- `runnerScale`（默认 1.0，先以 debug window 里观感为准）
- `runnerGroundY`（脚底贴地所需的 Y 偏移）
- `runnerYawRadians`（面向跑道方向）

建议先实现一个“可见即成功”的 MVP：

- runner 站在地面中心线附近（`x = 0`）
- Z 初始位置在相机前方（先给一个偏移，保证镜头能看到它）

#### 3.4 Reset 行为

在 `RunnerSceneAnimator.reset()` 中：

- 把 runner 位置复位到初始
- 把三段动画的权重复位为 idle=1, slow=0, fast=0
- 把 travel 变量（如果有）复位

### 关键点（坑位清单）

- **不要用 `rootNode.childNodes.first!` 猜节点**：USDZ 顶层经常有包装节点
- 更稳的办法：
  - 先找带 `skinner != nil` 的节点作为渲染用 `runnerNode`
  - 再找命名为 `Skeleton` 的节点作为动画挂载点（`skeletonNode`）

## Step 4：三动画同时播放 + 速度连续混合

### 动画挂载点

`Runner.usdz` 的动画 key 通常挂在 `Skeleton` 节点上（而不是 mesh 节点）。

### 建议先把“混合计算”抽成纯函数（可单测）

在 `VibeSports/Models/` 下新增一个纯模型（不依赖 SceneKit / SwiftUI / Combine）：

- `VibeSports/Models/Runner/RunnerAnimationBlender.swift`（示例命名）

职责：

- 输入：`speedMetersPerSecond`
- 输出：三段权重 `idle/slow/fast`（和为 1）以及 `playbackRate`

对应测试：

- `VibeSportsTests/RunnerAnimationBlenderTests.swift`
  - 权重和为 1（允许极小误差）
  - `speed = 0` 时 idle=1
  - `speed = minRunSpeed` 附近 slow≈1
  - `speed >= maxRunSpeed` 时 fast≈1

这样做的好处：动画混合逻辑一旦稳定，就不需要靠肉眼调试来保证“不会出现权重异常”。

### 混合策略（连续）

三个动画（idle/slow/fast）同时 `play()`，通过 `SCNAnimationPlayer.blendFactor` 控制权重：

- `speed < idleThreshold`：纯 idle
- `idleThreshold ..< minRunSpeed`：idle -> slow 线性过渡
- `minRunSpeed ..< maxRunSpeed`：slow -> fast 线性过渡

并用 `SCNAnimationPlayer.speed` 让步频随真实速度变化（例如 clamp 到 `0.3...3.0`）。

### 推荐的具体参数（先写死，后续再调）

因为 `RunningSpeedModel.maxSpeedMetersPerSecond = 6`，所以可以先用：

- `idleThreshold = 0.10`
- `minRunSpeed = 1.50`
- `maxRunSpeed = 4.50`
- `baseSpeed = 2.00`（用于把速度映射到 playbackRate）
- `playbackRate = clamp(speed / baseSpeed, 0.3...3.0)`

### 推荐实现位置（避免把逻辑放 ViewModel）

混合计算建议放在 `RunnerSceneAnimator.renderer(_:updateAtTime:)` 内部：

- 好处：与渲染帧率一致（60fps），混合更平滑
- 速度值虽然 20Hz 更新，但可以在 Animator 内对 speed 做轻微低通滤波（可选）

可选优化（抖动明显时再做）：

- `displaySpeed = lerp(displaySpeed, speed, alpha)`，例如 `alpha = 0.2`

### 伪代码（Animator 侧最小可行实现）

```swift
// 1) install: 找到 skeletonNode
let skeletonNode = runnerRoot.childNode(withName: "Skeleton", recursively: true)

// 2) 取 3 个 key（key 可能是完整路径）
let idleKey = skeletonNode.animationKeys.first { $0.localizedCaseInsensitiveContains("Idle") }
let slowKey = skeletonNode.animationKeys.first { $0.localizedCaseInsensitiveContains("SlowRun") }
let fastKey = skeletonNode.animationKeys.first { $0.localizedCaseInsensitiveContains("FastRun") }

// 3) 取 player，并 play（repeat forever）
let idlePlayer = skeletonNode.animationPlayer(forKey: idleKey)
idlePlayer.animation.repeatCount = .greatestFiniteMagnitude
idlePlayer.play()

// slow/fast 同理

// 4) 每帧根据 speed 更新 blendFactor + speed
let blend = blender.blend(for: displaySpeed) // (idle, slow, fast, playbackRate)
idlePlayer.blendFactor = blend.idle
slowPlayer.blendFactor = blend.slow
fastPlayer.blendFactor = blend.fast
slowPlayer.speed = blend.playbackRate
fastPlayer.speed = blend.playbackRate
```

## Step 5：第三人称相机（跟随角色，而不是“相机本体向前飞”）

当前实现是“相机向前推进 + bob/sway”；第三人称推荐改成：

- 用一个 `travelZ` 表示世界推进（只影响跑道循环与角色 Z）
- `runnerNode.position.z = travelZ + runnerAheadOffset`
- `cameraNode.position = runnerNode.position + cameraOffset`
- bob/sway 只加在相机局部 offset 上（别叠进 travelZ）

### 建议的最小改动策略（不先动跑道 recycle）

为了降低风险，建议先把 “runner + camera follow” 做成 **在现有 cameraZ 推进基础上叠加**：

- 保留 `cameraNode.position.z += advance` 作为 travel 基准（跑道 recycle 逻辑不动）
- 令 `runner.position.z = cameraNode.position.z + runnerAheadOffset`
- 相机 lookAt runner（或 `SCNLookAtConstraint`）

这样能先快速验证“3D 角色 + 动画混合”闭环，再把 camera/runner/travelZ 解耦重构成更干净的第三人称。

## Step 6：移除旧的 RunnerAvatarView（emoji 小人）

当 3D 角色在场景里跑起来后：

- 删除 `RunnerGameView` 中对 `RunnerAvatarView` 的引用
- `RunnerAvatarView.swift` 可删除或留作备选

## 调试 Tips

- Quick Look 只能播“默认动画”，不能用它判断“是否只有一段动画”
- 以 Debug Window / 代码打印 `Skeleton.animationKeys` 为准
- 模型大小/朝向：优先在 DCC（或导出）阶段统一；运行时只做必要的 scale/rotation

## 常见坑（提前写进计划里，避免改到一半卡住）

- `Skeleton` 节点命名依赖导出结果：如果将来换模型，名字可能不是 `Skeleton`，需要改为“按类型/结构查找”或在构建脚本阶段统一命名。
- `animationKeys` 可能是完整 USD 路径，不要硬编码等号匹配；用 `contains("Idle")` 这类方式更稳。
- `RunnerSceneView.updateNSView` 会重复调用 `renderer.attach(to:)`：不要在 `attach` 里做“重复 install/addChild”，否则会越跑节点越多。
- 如果模型脚底漂浮/穿地：优先用 `runnerSkinnedNode.boundingBox` 做一次性 Y 偏移校准（而不是每帧瞎调）。

## 验证命令（修改代码过程中随时跑）

```bash
# 构建 Runner.usdz（如需重新生成）
bash scripts/build_runner_usdz.sh --help

# 资源检查（是否包含多余 skin）
usdzip -l - VibeSports/Resources/Runner.usdz

# 构建与测试
xcodebuild -project VibeSports.xcodeproj -scheme VibeSports -destination 'platform=macOS' build
xcodebuild -project VibeSports.xcodeproj -scheme VibeSports -destination 'platform=macOS' test
```
